import{_ as e,o as d,c as o,V as c}from"./chunks/framework.76457b72.js";const n="/vp-blog/assets/01.89acda1d.png",m=JSON.parse('{"title":"null 和 undefined 的区别","description":"看看祖师爷是怎么说的","frontmatter":{"title":"null 和 undefined 的区别","description":"看看祖师爷是怎么说的","date":"2023-05-02T03:06:05.000Z","tags":["Javascript"],"layout":"post","cover":{"image":"/vp-blog/covers/05.png"}},"headers":[],"relativePath":"docs/posts/null-和-undefined-的区别.md","filePath":"docs/posts/null-和-undefined-的区别.md","lastUpdated":1688777678000}'),l={name:"docs/posts/null-和-undefined-的区别.md"},t=c('<h2 id="前言-困惑的产生" tabindex="-1">前言：困惑的产生 <a class="header-anchor" href="#前言-困惑的产生" aria-label="Permalink to &quot;前言：困惑的产生&quot;">​</a></h2><p>平时，我们在使用 Javascript 时，<code>undefined</code> 和 <code>null</code> <strong>几乎</strong>没有区别。</p><p>而在使用 TS 时，我们又明确的可以知道，它们是完全两种不同的类型，不可以互相赋值，在使用时并不完全等价，这就对我们的使用造成了困惑：到底什么时候用哪个，到底有什么区别。</p><p>据我所知，目前 JS 是唯一一个拥有两个表示“空”的类型的语言。</p><h2 id="了解历史" tabindex="-1">了解历史 <a class="header-anchor" href="#了解历史" aria-label="Permalink to &quot;了解历史&quot;">​</a></h2><p>查阅了一些资料，了解到，最早的 js 的版本中，是只有 <code>null</code> 的，JS 的一些设计参照了其他语言，而 null 在类型转换时可以转换为 0。</p><p>在 C 语言中，函数执行成功或是失败是人为约定的，比如比较常见的约定是执行成功返回 0，失败则返回其他数字。</p><p>而如果我们的 JS 也是这样，null 在自动转换为 0 的时候，往往不容易发现错误。</p><p>不知道是不是这个原因，Brendan Eich 觉得 <code>null</code> 不够好， 又在后续的版本中又设计了一个 <code>undefined</code>，而且已经添加了并被广泛使用。</p><p><code>undefined</code> 在转换成数字类型时，返回 <code>NaN</code>，这是它们直接一个明显的区别。</p><h2 id="为什么大厂里不允许显示使用-undefined" tabindex="-1">为什么大厂里不允许显示使用 <code>undefined</code> <a class="header-anchor" href="#为什么大厂里不允许显示使用-undefined" aria-label="Permalink to &quot;为什么大厂里不允许显示使用 `undefined`&quot;">​</a></h2><p>看过一些分享，说大厂里不允许直接使用 <code>undefined</code>，而是使用 <code>void 0</code> 来代替，它的返回结果是 <code>undefined</code>。</p><p>因为，<code>undefined</code> 不是 JS 里的关键字，它是 <code>window.undefined</code>，即 window 上的一个变量，在现代的 JS 中，它被属性描述符号限制了不可修改了，避免我们犯低级错误。</p><p>而在非全局作用域下，我们依然可以 <code>let undefined = xxx</code> 这还是需要小心的，我们不妨学习大厂的做法，在 code review 时，避免团队里出现显示使用 <code>undefined</code> 的代码。</p><p><code>undefined</code> 是一个变量，<code>null</code> 是一个关键字，这是它们的第二个区别。</p><h2 id="看看祖师爷怎么说" tabindex="-1">看看祖师爷怎么说 <a class="header-anchor" href="#看看祖师爷怎么说" aria-label="Permalink to &quot;看看祖师爷怎么说&quot;">​</a></h2><p>截图是 2015 年的一则推文，地址是：<a href="https://twitter.com/BrendanEich/status/617450289889607681" target="_blank" rel="noreferrer">https://twitter.com/BrendanEich/status/617450289889607681</a></p><p><img src="'+n+'" alt=""></p><p>大致意思是一个开发者问为什么 <code>typeof null</code> 的结果是 <code>object</code>，祖师爷首先回复了，<code>null</code> 表示 <code>no object</code>, <code>undefined</code> 表示 <code>no value</code>。</p><p>随后回答了这个问题，表示 <code>typeof null</code> 的结果是 <code>object</code> 是一个漏洞。</p><p>所以第三个区别是 <code>typeof null</code> 的结果是 <code>object</code>，而 <code>typeof undefined</code> 是 <code>undefined</code>。</p><h2 id="总结-目前前端环境里的表现" tabindex="-1">总结：目前前端环境里的表现 <a class="header-anchor" href="#总结-目前前端环境里的表现" aria-label="Permalink to &quot;总结：目前前端环境里的表现&quot;">​</a></h2><p>我们知道：</p><ul><li>转换成 bool 时，它们都是 false。</li><li>如果我们仅声明一个变量，未赋值，它的值是 <code>undefined</code>，对象的没有赋值的属性也是一样。</li><li>JS 函数默认的返回值是 <code>undefined</code>。</li><li>原型链的终点是 <code>null</code>。</li><li>调用函数时，没有传入的参数会是 <code>undefined</code>。</li><li>在前端环境里的现成的实现里，如 <code>document.getElementById(&#39;&#39;)</code> 如果没有选择器匹配返回的是 null。这种实现和祖师爷说的是保持一致的，</li></ul><p>甚至我们如果把 <code>null</code> 的 <code>typeof</code> 的设计缺陷，理解为 <code>null</code> 是特别的一种对象，表示这个对象不存在，是“空对象”，也是没有问题的。</p><p>再总结一下，前文提到的具体几处区别：</p><ul><li><code>undefined</code> 在转换成数字类型时，回返回 <code>NaN</code>；<code>null</code> 则是 0。</li><li><code>undefined</code> 是一个变量，<code>null</code> 是一个关键字</li><li><code>typeof null</code> 的结果是 <code>object</code>，而 <code>typeof undefined</code> 是 <code>undefined</code>。</li></ul><p>在 JS 里我们混着用并没有什么区别，但是现在我们知道了一点它们的区别，祖师爷也给出了使用的建议，我们基本上按照他的建议来使用即可。</p>',28),a=[t];function i(u,p,r,s,f,h){return d(),o("div",null,a)}const b=e(l,[["render",i]]);export{m as __pageData,b as default};
