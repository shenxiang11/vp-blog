import{_ as e,o,c as t,V as a}from"./chunks/framework.09b837aa.js";const m=JSON.parse('{"title":"学习 React Hooks（五）","description":"useMemo, useCallback, useContext","frontmatter":{"title":"学习 React Hooks（五）","description":"useMemo, useCallback, useContext","date":"2023-06-05T01:42:31.000Z","tags":["React"],"layout":"post","cover":{"image":"/vp-blog/covers/react.jpeg"}},"headers":[],"relativePath":"docs/posts/learn-hook-5.md","filePath":"docs/posts/learn-hook-5.md","lastUpdated":1686565618000}'),c={name:"docs/posts/learn-hook-5.md"},s=a('<h2 id="usememo" tabindex="-1">useMemo <a class="header-anchor" href="#usememo" aria-label="Permalink to &quot;useMemo&quot;">​</a></h2><p><code>useMemo</code> 是一个 React Hook，它在每次重新渲染的时候能够缓存计算的结果。</p><p>官网说了它也是仅在少数情况有价值，比如依赖关系很少改变时。</p><h2 id="usecallback" tabindex="-1">useCallback <a class="header-anchor" href="#usecallback" aria-label="Permalink to &quot;useCallback&quot;">​</a></h2><p><code>useCallback</code> 是一个 React Hook，用来在多次渲染之间缓存函数。</p><p><code>useMemo</code> 已经可以做到缓存函数了，它的出现是为了避免出现嵌套的写法。</p><p>如果在缓存的函数里使用 <code>setState</code>，使用 <code>setState</code> 的函数更新形式可以减少依赖项。</p><h2 id="usecontext" tabindex="-1">useContext <a class="header-anchor" href="#usecontext" aria-label="Permalink to &quot;useContext&quot;">​</a></h2><p><code>useContext</code> 是一个 React Hook，可以让你读取和订阅组件中的 context。</p><p>这个我在之前手写 Redux 时有应用。</p><p>在 <code>createContext</code> 时可以指定默认值，防止有时没有匹配的 <code>provider</code>。</p>',11),d=[s];function r(l,n,p,u,i,_){return o(),t("div",null,d)}const k=e(c,[["render",r]]);export{m as __pageData,k as default};
